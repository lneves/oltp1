package org.oltp1.egen.generator;

import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.PriorityQueue;

import org.oltp1.egen.io.DataFileManager;
import org.oltp1.egen.io.records.ChargeDataFileRecord;
import org.oltp1.egen.io.records.CommissionRateDataFileRecord;
import org.oltp1.egen.io.records.ExchangeDataFileRecord;
import org.oltp1.egen.io.records.StatusTypeDataFileRecord;
import org.oltp1.egen.io.records.TradeTypeDataFileRecord;
import org.oltp1.egen.model.AccountSecurity;
import org.oltp1.egen.model.AdditionalTradeInfo;
import org.oltp1.egen.model.BrokerRow;
import org.oltp1.egen.model.CashTransactionRow;
import org.oltp1.egen.model.ExchangeType;
import org.oltp1.egen.model.HoldingHistoryRow;
import org.oltp1.egen.model.HoldingInfo;
import org.oltp1.egen.model.HoldingRow;
import org.oltp1.egen.model.HoldingSummaryRow;
import org.oltp1.egen.model.SettlementRow;
import org.oltp1.egen.model.StatusType;
import org.oltp1.egen.model.TaxStatus;
import org.oltp1.egen.model.TradeHistoryRow;
import org.oltp1.egen.model.TradeInfo;
import org.oltp1.egen.model.TradeOutputRow;
import org.oltp1.egen.model.TradeRow;
import org.oltp1.egen.model.TradeType;
import org.oltp1.egen.util.DateTime;
import org.oltp1.egen.util.Money;
import org.oltp1.egen.util.TpcRandom;

/*
*   Class that generates trades and holdings for a given set
*   of customers. It maintains the proper holding information
*   for every customer while the trades are being generated.
*
*   TRADE, TRADE_HISTORY, CASH_TRANSACTION, SETTLEMENT,
*   HOLDING, HOLDING_HISTORY rows are generated by this class.
*/
public class TradeGen
{
	// Constants
	public static final int MAX_HOLDING_HISTORY_ROWS_PER_TRADE = 800 / 100;
	public static final long TRADE_SHIFT = 200000000000000L; // 200 trillion (2 * 10^14)
	private static final long IDENT_T_SHIFT = 4300000000L;
	public static final long DEFAULT_START_FROM_CUSTOMER = 1;
	public static final int MAX_SECURITIES_PER_ACCOUNT = 18;
	public static final int MAX_ACCOUNTS_PER_CUST = 10;

	// Number of RNG calls for one simulated trade
	private static final int RNG_SKIP_ONE_TRADE = 11; // average count for v3.5: 6.5
	private static final long RNG_SEED_TRADE_GEN = 32900134L;

	public static final short INITIAL_TRADE_POPULATION_BASE_YEAR = 2005;
	public static final short INITIAL_TRADE_POPULATION_BASE_MONTH = 1;
	public static final short INITIAL_TRADE_POPULATION_BASE_DAY = 3;
	public static final short INITIAL_TRADE_POPULATION_BASE_HOUR = 9;
	public static final short INITIAL_TRADE_POPULATION_BASE_MINUTE = 0;
	public static final short INITIAL_TRADE_POPULATION_BASE_SECOND = 0;
	public static final int INITIAL_TRADE_POPULATION_BASE_FRACTION = 0;

	public static final int ABORT_TRADE = 101;
	public static final int ABORTED_TRADE_MOD_FACTOR = 51;

	public static final double NS_PER_SECOND_DIVISOR = 1000000000.0;
	public static final long NS_PER_SECOND = 1000000000;
	public static final double MS_PER_SECOND_DIVISOR = 1000.000;
	public static final long MS_PER_SECOND = 1000;
	public static final long SECONDS_PER_MINUTE = 60;
	public static final long MINUTES_PER_HOUR = 60;
	public static final long HOURS_PER_DAY = 24;
	public static final long HOURS_PER_WORK_DAY = 8;
	public static final long DAYS_PER_WORK_WEEK = 5;
	public static final long DAYS_PER_WEEK = 7;
	public static final long SECONDS_PER_HOUR = SECONDS_PER_MINUTE * MINUTES_PER_HOUR;
	public static final long SECONDS_PER_DAY = SECONDS_PER_MINUTE * MINUTES_PER_HOUR * HOURS_PER_DAY;
	public static final long SECONDS_PER_WORK_DAY = SECONDS_PER_MINUTE * MINUTES_PER_HOUR * HOURS_PER_WORK_DAY;
	public static final long MS_PER_DAY = SECONDS_PER_DAY * MS_PER_SECOND;
	public static final long MS_PER_WORK_DAY = SECONDS_PER_WORK_DAY * MS_PER_SECOND;

	public static final int NUM_TRADE_QTY_SIZES = 4;
	public static final int[] TRADE_QTY_SIZES = { 100, 200, 400, 800 };
	public static final double MIN_SEC_PRICE = 20.00;
	public static final double MAX_SEC_PRICE = 30.00;
	public static final int PERCENT_TRADE_IS_LIFO = 35;

	private static final int MARKET_BUY_LOAD_THRESHOLD = 30;
	private static final int MARKET_SELL_LOAD_THRESHOLD = 60;
	private static final int LIMIT_BUY_LOAD_THRESHOLD = 80;
	private static final int LIMIT_SELL_LOAD_THRESHOLD = 90;
	private static final int STOP_LOSS_LOAD_THRESHOLD = 100;

	private static final int PERCENT_BUYS_ON_MARGIN = 16;

	// Member variables

	// RNG class for generation of row data
	private TpcRandom rnd;

	// Class used to get address information for a customer
	// to properly calculate tax on a trade
	private AddressTable addressTable;

	// Class used to select a random customer for whom to perform a trade.
	private CustomerSelection customerSelection;

	// Class used to get CUSTOMER table information for a specific customer
	private CustomerTable customerTable;

	// Class used to calculate T_TAX for the TRADE table
	private CustomerTaxRateTable custTaxrateTable;

	// Class used to get customer account information.
	private CustomerAccountsAndPermissionsTable customerAccountTable;

	// Class used in determining the basket of securities for an account
	private HoldingsAndTradesTable holdingTable;

	// Class used to generate BROKER table (with consistent YTD columns)
	private BrokerTable brokerTable;

	// Class used to get S_NAME for cash transaction descriptions
	private SecurityTable securityTable;

	// Class to get the first and last names of a customer
	private Person person;

	// Input files for character data generation.
	private final CompanyFile companyFile;
	private final SecurityFile securityFile;
	private final List<ChargeDataFileRecord> chargeFile; // CHARGE table from the flat file
	private final List<CommissionRateDataFileRecord> commissionRateFile; // COMMISSION_RATE table from the flat file
	private final List<StatusTypeDataFileRecord> statusTypeFile; // STATUS_TYPE table from the flat file
	private final List<TradeTypeDataFileRecord> tradeTypeFile; // TRADE_TYPE table from the flat file
	private final List<ExchangeDataFileRecord> exchangeFile; // EXCHANGE table from the flat file

	// The first customer to generate for this class instance
	private long startFromCustomer;
	// First account of the StartFromCustomer
	private long startFromAccount;
	// Number of customers for this class instance
	private long customerCount;
	// Total number of customers in the database
	private long totalCustomers;
	// Number of customers in one load unit
	private int loadUnitSize;
	// Number of accounts for customers in one load unit
	private int loadUnitAccountCount;
	// Number of customers for 1 tpsE
	private int scaleFactor;
	// Number of hours of initial trades to generate
	private int hoursOfInitialTrades;

	// Average number of seconds between two consecutive trades
	private double meanTimeBetweenTrades;

	// Mean delay between Pending and Submission times
	// for an immediately triggered (in-the-money) limit order.
	private double meanInTheMoneySubmissionDelay;

	// Time at which to start trade timestamps (time 0 or StartTime).
	// Not changed during the class lifetime.
	// This is the submission (or pending) time of the first trade.
	private DateTime startTime;

	// Current Trade Order time in the simulated time sequence (seconds from
	// StartTime).
	// When this time is further than the priority queue's front, incomplete trades
	// are removed from the priority queue and completed.
	// If this time is before the priority queue front time, new incomplete trades
	// are placed on the queue and this time is incremented.
	private double currentSimulatedTime;

	// Priority queue that contains incomplete trades ordered by their completion
	// time.
	// The queue's front contains trade with the earliest completion time.
	private PriorityQueue<TradeInfo> currentTrades;

	// Number of trades completed up to now. Does not include aborted trades.
	private long currentCompletedTrades;

	// Number of total trades needed to generate. Does not include aborted trades.
	private long totalTrades;

	// Number of trades initiated up to now. Includes aborted trades.
	// Needed to calculate when to abort a trade at Trade Order time.
	private long currentInitiatedTrades;

	// Number of trades in an 8-hour workday.
	// Needed to know when to move trading time to the next day.
	private int tradesPerWorkDay;

	// 3-dimensional array of double-linked lists each containing
	// one customer holding information.
	// The array is indexed as follows:
	// [AccountId][SecurityIndexWithinAccount]
	// There is no need to index on customer id since the account
	// id is unique across the universe of all customers
	private List<HoldingInfo>[][] customerHoldings;

	// Structure to contain incomplete, but essential trade information generated at
	// Trade Order time.
	private TradeInfo newTrade;

	// Structure to contain trade non-essential information frequently used at Trade
	// Result time.
	private AdditionalTradeInfo completedTradeInfo;

	// Structure to contain current trade and holding table rows.
	// Filled in generateNextTrade() for trade-related tables and in
	// generateNextHolding for holding-related tables.
	private TradeOutputRow tradeOutputRow;
	private HoldingRow holdingRow;

	// Structure to contain HOLDING_SUMMARY rows.
	// Filled in generateNextHoldingSummaryRow.
	private HoldingSummaryRow holdingSummaryRow;

	// Number of Trade History rows for the current trade in tradeOutputRow.
	private int tradeHistoryRowCount;

	// Number of Cash Transaction rows for the current trade in tradeOutputRow.
	private int cashTransactionRowCount;

	// Number of Settlement rows for the current trade in tradeOutputRow.
	private int settlementRowCount;

	// Number of Holding History rows. May be more than one if the trade modifies
	// more than one holding.
	private int holdingHistoryRowCount;

	// Security price emulation
	private MEESecurity meeSecurity;

	// Account, security index, and security holding to use in generateNextHolding()
	// to return the next holding.
	private int currentAccountForHolding;
	private int currentSecurityForHolding; // index within the account (not input file)
	private Iterator<HoldingInfo> currentSecurityHoldingIterator;

	// Account index and security index, used in generateNextHoldingSummaryRecord().
	private int currentAccountForHoldingSummary; // index
	private int currentSecurityForHoldingSummary; // index

	// Trade ID for the last generated trade. Positioned at the correct trade id at
	// start.
	private long currentTradeId;

	// Current load unit number
	private int currentLoadUnit;

	private boolean hasMoreTrades;

	/**
	 * Constructor
	 */
	@SuppressWarnings("unchecked")
	public TradeGen(DataFileManager dfm,
			long customerCount,
			long startFromCustomer,
			long totalCustomers,
			int loadUnitSize,
			int scaleFactor,
			int hoursOfInitialTrades)
	{
		this.rnd = new TpcRandom(RNG_SEED_TRADE_GEN);
		this.addressTable = new AddressTable(dfm, customerCount, startFromCustomer, true); // only customer addresses
		this.customerSelection = new CustomerSelection(rnd, 0, 0, 100, startFromCustomer, loadUnitSize); // only generate customer within partition
		this.customerTable = new CustomerTable(dfm, customerCount, startFromCustomer);
		this.custTaxrateTable = new CustomerTaxRateTable(dfm, customerCount, startFromCustomer);
		this.customerAccountTable = new CustomerAccountsAndPermissionsTable(dfm, loadUnitSize, customerCount, startFromCustomer);
		this.holdingTable = new HoldingsAndTradesTable(dfm, loadUnitSize, customerCount, startFromCustomer);
		this.brokerTable = new BrokerTable(dfm, customerCount, startFromCustomer);
		this.securityTable = new SecurityTable(dfm, customerCount, startFromCustomer);

		this.person = new Person(dfm, startFromCustomer, false);

		this.companyFile = dfm.getCompanyFile();
		this.securityFile = dfm.getSecurityFile();
		this.chargeFile = dfm.getChargeDataFile();
		this.commissionRateFile = dfm.getCommissionRateDataFile();
		this.statusTypeFile = dfm.getStatusTypeDataFile();
		this.tradeTypeFile = dfm.getTradeTypeDataFile();
		this.exchangeFile = dfm.getExchangeDataFile();

		this.startFromCustomer = startFromCustomer + IDENT_T_SHIFT;
		this.customerCount = customerCount;
		this.totalCustomers = totalCustomers;
		this.loadUnitSize = loadUnitSize;
		this.loadUnitAccountCount = loadUnitSize * MAX_ACCOUNTS_PER_CUST;
		this.scaleFactor = scaleFactor;
		this.hoursOfInitialTrades = hoursOfInitialTrades;
		this.meanTimeBetweenTrades = 100.0 / ABORT_TRADE * (double) scaleFactor / loadUnitSize;
		this.meanInTheMoneySubmissionDelay = 1.0;
		this.currentSimulatedTime = 0;
		this.currentCompletedTrades = 0;
		this.totalTrades = (long) hoursOfInitialTrades * SECONDS_PER_HOUR * loadUnitSize / scaleFactor;
		this.currentInitiatedTrades = 0;
		this.tradesPerWorkDay = (int) (HOURS_PER_WORK_DAY * SECONDS_PER_HOUR * loadUnitSize / scaleFactor * ABORT_TRADE / 100);
		this.meeSecurity = new MEESecurity();
		this.currentAccountForHolding = 0;
		this.currentSecurityForHolding = 0;
		this.currentAccountForHoldingSummary = 0;
		this.currentSecurityForHoldingSummary = -1; // incremented in findNextHoldingList()
		this.currentLoadUnit = 0;

		// Initialize priority queue with custom comparator
		this.currentTrades = new PriorityQueue<>((a, b) -> a.compareTo(b));

		// Set the start time (time 0) to the base time
		this.startTime = new DateTime(0);
		this.startTime
				.set(
						INITIAL_TRADE_POPULATION_BASE_YEAR,
						INITIAL_TRADE_POPULATION_BASE_MONTH,
						INITIAL_TRADE_POPULATION_BASE_DAY,
						INITIAL_TRADE_POPULATION_BASE_HOUR,
						INITIAL_TRADE_POPULATION_BASE_MINUTE,
						INITIAL_TRADE_POPULATION_BASE_SECOND,
						INITIAL_TRADE_POPULATION_BASE_FRACTION);

		// Get the first account number
		this.startFromAccount = customerAccountTable.getStartingAccountId(this.startFromCustomer);

		// Create an array of customer holding lists
		this.customerHoldings = new List[loadUnitAccountCount][MAX_SECURITIES_PER_ACCOUNT];
		for (int i = 0; i < loadUnitAccountCount; i++)
		{
			for (int j = 0; j < MAX_SECURITIES_PER_ACCOUNT; j++)
			{
				customerHoldings[i][j] = new LinkedList<>();
			}
		}

		// Clear row structures
		this.newTrade = new TradeInfo();
		this.tradeOutputRow = new TradeOutputRow();
		this.holdingRow = new HoldingRow();
		this.holdingSummaryRow = new HoldingSummaryRow();
		this.completedTradeInfo = new AdditionalTradeInfo();

		// Position trade id at the proper start of the sequence
		this.currentTradeId = hoursOfInitialTrades * SECONDS_PER_HOUR
				* (startFromCustomer - DEFAULT_START_FROM_CUSTOMER)
				/ scaleFactor // divide after multiplication to avoid integer truncation
				* ABORT_TRADE
				/ 100 + TRADE_SHIFT;

		// Initialize BROKER table
		brokerTable.initForGen(loadUnitSize, this.startFromCustomer - IDENT_T_SHIFT);

		long rngSkipCount = this.startFromCustomer / loadUnitSize * totalTrades;

		rnd.setSeed(TpcRandom.rndNthElement(RNG_SEED_TRADE_GEN, rngSkipCount * RNG_SKIP_ONE_TRADE));

		holdingTable.initNextLoadUnit(rngSkipCount, startFromAccount);

		// Initialize security price emulation
		meeSecurity.init(0, null, null, meanInTheMoneySubmissionDelay);

		this.hasMoreTrades = (currentCompletedTrades < totalTrades);
	}

	/**
	 * Initialize next load unit for a series of
	 * generateNextTrade/generateNextHolding calls.
	 * 
	 * The first load unit doesn't have to be initialized.
	 * 
	 * @return true if a new load unit could be found, false if all load units have
	 *         been processed
	 */
	@SuppressWarnings("unchecked")
	public boolean initNextLoadUnit()
	{
		currentLoadUnit++;
		currentCompletedTrades = 0;

		// No need to empty holdings as they were emptied by generateNextHolding calls.
		// Create an array of customer holding lists
		customerHoldings = new List[loadUnitAccountCount][MAX_SECURITIES_PER_ACCOUNT];
		for (int i = 0; i < loadUnitAccountCount; i++)
		{
			for (int j = 0; j < MAX_SECURITIES_PER_ACCOUNT; j++)
			{
				customerHoldings[i][j] = new LinkedList<>();
			}
		}

		currentAccountForHolding = 0;
		currentSecurityForHolding = 0;

		currentAccountForHoldingSummary = 0;
		currentSecurityForHoldingSummary = -1;

		startFromCustomer += loadUnitSize;
		startFromAccount = customerAccountTable.getStartingAccountId(startFromCustomer);
		currentSimulatedTime = 0;
		currentInitiatedTrades = 0;

		brokerTable.initForGen(loadUnitSize, startFromCustomer - IDENT_T_SHIFT);

		long rngSkipCount = startFromCustomer / loadUnitSize * totalTrades;
		rnd.setSeed(TpcRandom.rndNthElement(RNG_SEED_TRADE_GEN, rngSkipCount * RNG_SKIP_ONE_TRADE));

		// Move customer range for the next load unit.
		customerSelection.setPartitionRange(startFromCustomer, loadUnitSize);

		holdingTable.initNextLoadUnit(rngSkipCount, startFromAccount);
		person.initNextLoadUnit();
		addressTable.initNextLoadUnit();
		customerAccountTable.initNextLoadUnit();

		meeSecurity.init(0, null, null, meanInTheMoneySubmissionDelay);

		// Clear row structures.
		tradeOutputRow = new TradeOutputRow();
		holdingRow = new HoldingRow();
		holdingSummaryRow = new HoldingSummaryRow();

		return currentLoadUnit < (customerCount / loadUnitSize);
	}

	public boolean hasMoreTrades()
	{
		return hasMoreTrades;
	}

	/**
	 * Generate a new trade and all trade-related rows (except holdings).
	 * 
	 * @return true if there are more trades, false if there are no more trades to
	 *         generate
	 */
	public boolean generateNextTrade()
	{
		boolean moreTrades;

		if (currentCompletedTrades < totalTrades)
		{
			// While the earliest completion time is before the current
			// simulated ('Trade Order') time, keep creating new
			// incomplete trades putting them on the queue and
			// incrementing the current simulated time.

			while ((currentCompletedTrades + currentTrades.size() < totalTrades) &&
					(currentTrades.isEmpty() || (currentSimulatedTime < currentTrades.peek().completionTime)))
			{

				currentSimulatedTime = (currentInitiatedTrades / tradesPerWorkDay) // number of days
						* SECONDS_PER_DAY // number of seconds in a day
						// now add the offset in the day
						+ (currentInitiatedTrades % tradesPerWorkDay) * meanTimeBetweenTrades
						+ generateDelayBetweenTrades();

				// Generate new Trade Order; MEESecurity is used by this function.
				generateNewTrade();

				if (holdingTable.isAbortedTrade(currentInitiatedTrades))
				{
					// Abort trade and not put it into the queue.
					// Generate a new trade instead.
					continue;
				}

				currentTrades.offer(newTrade.copy()); // Add copy to queue
			}

			// Get the earliest trade from the front of the queue.
			newTrade = currentTrades.poll();

			// Update HOLDING row for the customer
			// Must be called before generating the complete trade
			// to calculate buy and sell values for T_TAX.
			updateHoldings();

			// Generate all the remaining trade data.
			generateCompleteTrade();

			moreTrades = currentCompletedTrades < totalTrades;
			this.hasMoreTrades = moreTrades;
		}
		else
		{
			moreTrades = false;
			this.hasMoreTrades = false;
		}

		if (moreTrades)
		{
			return true;
		}
		else
		{
			// Before returning need to position holding iterator for generateNextHolding()
			if (!customerHoldings[currentAccountForHolding][currentSecurityForHolding].isEmpty())
			{
				currentSecurityHoldingIterator = customerHoldings[currentAccountForHolding][currentSecurityForHolding].iterator();
			}
			findNextHolding();

			// Set up for generateNextHoldingSummary
			findNextHoldingList();

			int queueSize = currentTrades.size(); // info for debugging
			assert queueSize == 0;

			return false;
		}
	}

	/**
	 * Generate a random delay in Submission (or Pending for limit trades) time
	 * between two trades.
	 * 
	 * @return seconds of delay before simulated time for the next trade
	 */
	private double generateDelayBetweenTrades()
	{
		// Return a random number between 0 and 1ms less than the mean.
		return rnd.rndDoubleIncrRange(0.0, meanTimeBetweenTrades - 0.001, 0.001);
	}

	/**
	 * Helper function to get the list of holdings to modify after the last
	 * completed trade
	 * 
	 * @return reference to the list of holdings
	 */
	private List<HoldingInfo> getHoldingListForCurrentTrade()
	{
		int ix0 = (int) (getCurrentAccID() - startFromAccount);
		int ix1 = getCurrentSecurityAccountIndex() - 1;
		return customerHoldings[ix0][ix1];
	}

	/**
	 * Helper function to get either the front or the end of the holding list
	 * 
	 * @param holdingList
	 *            the holding list
	 * @param isLifo
	 *            whether to use LIFO ordering
	 * @return iterator positioned at the appropriate element
	 */
	private ListIterator<HoldingInfo> positionAtHoldingList(List<HoldingInfo> holdingList, boolean isLifo)
	{
		if (holdingList.isEmpty())
		{
			return holdingList.listIterator();
		}
		else
		{
			if (isLifo)
			{
				return holdingList.listIterator(holdingList.size()); // position at end
			}
			else
			{
				return holdingList.listIterator(0); // position at beginning
			}
		}
	}

	public TradeRow getTradeRow()
	{
		return tradeOutputRow.trade;
	}

	public int getTradeHistoryRowCount()
	{
		return tradeHistoryRowCount;
	}

	public TradeHistoryRow getTradeHistoryRow(int i)
	{
		return tradeOutputRow.tradeHistory[i];
	}

	public int getSettlementRowCount()
	{
		return settlementRowCount;
	}

	public SettlementRow getSettlementRow()
	{
		return tradeOutputRow.settlement;
	}

	public int getCashTransactionRowCount()
	{
		return cashTransactionRowCount;
	}

	public CashTransactionRow getCashTransactionRow()
	{
		return tradeOutputRow.cashTransaction;
	}

	public HoldingRow getHoldingRow()
	{
		return holdingRow;
	}

	public int getHoldingHistoryRowCount()
	{
		return holdingHistoryRowCount;
	}

	public HoldingHistoryRow getHoldingHistoryRow(int i)
	{
		return tradeOutputRow.holdingHistory[i];
	}

	public HoldingSummaryRow getHoldingSummaryRow()
	{
		return holdingSummaryRow;
	}

	public boolean generateNextBrokerRecord()
	{
		brokerTable.generateNextRecord();
		return brokerTable.hasMoreRecords();
	}

	public BrokerRow getBrokerRow()
	{
		return brokerTable.getRow();
	}

	private long getCurrentCustID()
	{
		return newTrade.customer;
	}

	private int getCurrentCustTier()
	{
		return newTrade.customerTier;
	}

	private long getCurrentAccID()
	{
		return newTrade.customerAccount;
	}

	private long getCurrentTradeID()
	{
		return newTrade.tradeId;
	}

	private Money getCurrentBidPrice()
	{
		return newTrade.bidPrice;
	}

	private Money getCurrentTradePrice()
	{
		return newTrade.tradePrice;
	}

	private int getCurrentTradeQty()
	{
		return newTrade.tradeQty;
	}

	private TradeType getCurrentTradeType()
	{
		return newTrade.tradeType;
	}

	private StatusType getCurrentTradeStatus()
	{
		return newTrade.tradeStatus;
	}

	private boolean getCurrentTradeIsCash()
	{
		return tradeOutputRow.trade.T_IS_CASH;
	}

	private long getCurrentSecurityIndex()
	{
		return newTrade.symbolIndex;
	}

	private int getCurrentSecurityAccountIndex()
	{
		return newTrade.symbolIndexInAccount;
	}

	private boolean getCurrentTradeIsLifo()
	{
		return newTrade.isLifo;
	}

	/*
	 * Generate a new holding row. This function uses already prepared holding list
	 * structure and returns the next holding for the current customer.
	 *
	 * The returned holding is deleted from the holding list to clear the list for
	 * the next load unit.
	 *
	 * It moves to the next customer if the current one doesn't have any more
	 * holdings.
	 *
	 * PARAMETERS: none RETURNS: true - if there are more holdings false - if there
	 * are no more holdings to return
	 */
	public boolean generateNextHolding()
	{
		// Check if the holding iterator has moved past the last account. If so, we're
		// done.
		if (currentAccountForHolding >= loadUnitAccountCount)
		{
			return false;
		}

		// The findNextHolding() helper ensures that the iterator is valid and has a
		// next element.
		// Retrieve the current holding object and advance the iterator.
		HoldingInfo current = currentSecurityHoldingIterator.next();

		// Populate the holdingRow member variable with data from the current holding.
		holdingRow.H_CA_ID = currentAccountForHolding + startFromAccount;
		holdingRow.H_S_SYMB = securityFile.createSymbol(current.symbolIndex);
		holdingRow.H_T_ID = current.tradeId;
		holdingRow.H_QTY = current.tradeQty;
		holdingRow.H_PRICE = current.tradePrice.dollarAmount();
		holdingRow.H_DTS = current.buyDts;

		// Call findNextHolding() to position the iterators for the NEXT call.
		// The return value indicates if there are any more holdings left to process.
		return findNextHolding();
	}

	/**
	 * Generates a new incomplete trade (a "Trade Order" event).
	 * <p>
	 * This method populates the {@code newTrade} member variable with all the
	 * necessary information to simulate a trade from pending to completion. It
	 * selects a random customer, account, and security, generates a trade type,
	 * quantity, and price, and then uses the MEESecurity model to calculate the
	 * submission and completion timestamps.
	 */
	// private int debug_counter = 0;
	private void generateNewTrade()
	{
		// Assign a unique ID for the new trade.
		newTrade.tradeId = generateNextTradeId();

		// Select a random customer.
		RandomCustomer cInfo = customerSelection.generateRandomCustomer();
		newTrade.customer = cInfo.getCustomerId();
		newTrade.customerTier = cInfo.getCustomerTier().getValue();

		// Select a random account and security for that customer.
		AccountSecurity securityInfo = holdingTable.generateRandomAccountSecurity(newTrade.customer, cInfo.getCustomerTier());
		newTrade.customerAccount = securityInfo.caId;
		newTrade.symbolIndex = securityInfo.securityFlatFileIndex;
		newTrade.symbolIndexInAccount = securityInfo.securityAccountIndex;

		// Generate trade parameters.
		newTrade.tradeType = generateTradeType();
		newTrade.tradeStatus = StatusType.COMPLETED; // For initial load, all trades are completed.

		newTrade.bidPrice = new Money(rnd.rndDoubleIncrRange(MIN_SEC_PRICE, MAX_SEC_PRICE, 0.01));

		newTrade.tradeQty = TRADE_QTY_SIZES[rnd.rndIntRange(0, NUM_TRADE_QTY_SIZES - 1)];

		double calculated_submissionTime = 0.0;
		double calculated_trade_price = 0.0;

		// Calculate timing based on whether it's a Market or Limit order.
		if (newTrade.tradeType == TradeType.MARKET_BUY || newTrade.tradeType == TradeType.MARKET_SELL)
		{
			// Market orders submit immediately at the current simulated time.
			newTrade.submissionTime = currentSimulatedTime;
			// The bid price is updated to the actual market price at submission.
			newTrade.bidPrice = meeSecurity.calculatePrice(newTrade.symbolIndex, currentSimulatedTime);
		}
		else
		{
			// Limit orders are pending until the price is met.
			newTrade.pendingTime = currentSimulatedTime;
			calculated_submissionTime = meeSecurity
					.getSubmissionTime(
							newTrade.symbolIndex,
							newTrade.pendingTime,
							newTrade.bidPrice,
							newTrade.tradeType);
			newTrade.submissionTime = calculated_submissionTime;

			// Adjust for market hours: if a trade would submit after 5 PM, move it to 9 AM
			// the next day.
			boolean isAfterMarketClose = (((int) (newTrade.submissionTime / 3600)) % HOURS_PER_DAY == HOURS_PER_WORK_DAY) &&
					(newTrade.submissionTime / 3600.0 - (int) (newTrade.submissionTime / 3600.0) > 0);

			if (isAfterMarketClose)
			{
				newTrade.submissionTime += 16 * 3600; // Add 16 hours to move from 5 PM to 9 AM next day.
			}
		}

		// Calculate final completion time and price using the market emulation model.
		MEESecurity.CompletionResult completion = meeSecurity.getCompletionTime(newTrade.symbolIndex, newTrade.submissionTime);
		newTrade.completionTime = completion.completionTime;
		newTrade.tradePrice = completion.completionPrice;

		calculated_trade_price = completion.completionPrice.dollarAmount();

		// For limit orders, ensure the executed price is not worse than the limit
		// price.
		boolean isLimitBuyViolation = newTrade.tradeType == TradeType.LIMIT_BUY && newTrade.bidPrice.compareTo(newTrade.tradePrice) < 0;
		boolean isLimitSellViolation = newTrade.tradeType == TradeType.LIMIT_SELL && newTrade.bidPrice.compareTo(newTrade.tradePrice) > 0;

		if (isLimitBuyViolation || isLimitSellViolation)
		{
			newTrade.tradePrice = newTrade.bidPrice;
		}

		// Randomly set the LIFO (Last-In-First-Out) flag.
		newTrade.isLifo = rnd.rndPercent(PERCENT_TRADE_IS_LIFO);

		// Increment the count of total trades initiated.
		currentInitiatedTrades++;

		// if (debug_counter < 25)
		// {
		// System.out.println(newTrade);
		// System.out.println("rnd_seed: " + rnd.getSeed());
		// System.out.println("currentSimulatedTime: " + currentSimulatedTime);
		// System.out.println("calculated_submissionTime: " +
		// calculated_submissionTime);
		// System.out.println("calculated_trade_price: " + calculated_trade_price);
		// debug_counter++;
		// }
	}

	private long generateNextTradeId()
	{
		return ++currentTradeId;
	}

	/**
	 * Generates frequently used, derived information for the completed trade.
	 * <p>
	 * This method gathers external information (tax status, broker ID) and calls a
	 * sequence of helper methods to calculate the trade's charge, commission, tax,
	 * and final settlement amount. The results are stored in the
	 * {@code completedTradeInfo} member variable for use by other row-generation
	 * methods. This method must be called before generating the final table rows.
	 */
	private void generateCompletedTradeInfo()
	{
		// Get account-specific information needed for financial calculations.
		completedTradeInfo.accountTaxStatus = customerAccountTable.getAccountTaxStatus(getCurrentAccID());
		completedTradeInfo.currentBrokerId = customerAccountTable.generateBrokerIdForAccount(getCurrentAccID());
		// Call specialized methods to calculate each financial component in order.
		generateTradeCharge();
		generateTradeCommission();
		generateTradeTax();
		generateSettlementAmount();
	}

	/**
	 * Calculates the final settlement amount for the trade.
	 * <p>
	 * This method computes the net cash flow of the transaction. For sells, fees
	 * are subtracted from the proceeds. For buys, fees are added to the cost.
	 * Finally, if taxes are withheld, they are also subtracted from the settlement
	 * amount.
	 */
	private void generateSettlementAmount()
	{
		boolean isSell = tradeTypeFile.get(getCurrentTradeType().ordinal()).tt_is_sell;
		Money tradeValue = getCurrentTradePrice().multiply(getCurrentTradeQty());

		// Determine base settlement amount based on buy or sell.
		if (isSell)
		{
			// For a sell, customer receives cash: trade value - fees.
			completedTradeInfo.settlementAmount = tradeValue
					.subtract(completedTradeInfo.charge)
					.subtract(completedTradeInfo.commission);
		}
		else
		{
			// For a buy, customer pays cash: -(trade value + fees).
			completedTradeInfo.settlementAmount = tradeValue
					.add(completedTradeInfo.charge)
					.add(completedTradeInfo.commission)
					.negate();
		}

		// Adjust for withheld taxes, if applicable.
		if (getCurrentTaxStatus() == TaxStatus.TAXABLE_AND_WITHHOLD)
		{
			completedTradeInfo.settlementAmount = completedTradeInfo.settlementAmount
					.subtract(completedTradeInfo.tax);
		}
	}

	/**
	 * Calculates capital gains tax for the trade.
	 * <p>
	 * If the trade resulted in a profit (sell value > buy value), this method
	 * calculates the tax based on the sum of country and division tax rates for the
	 * customer's address. If there is no profit, the tax is zero.
	 */
	private void generateTradeTax()
	{
		// Tax is only applicable on trades with a capital gain.
		if (getCurrentTradeSellValue().lessThanOrEqual(getCurrentTradeBuyValue()))
		{
			completedTradeInfo.tax = new Money();
			return;
		}

		Money proceeds = getCurrentTradeSellValue().subtract(getCurrentTradeBuyValue());

		// Get customer's location to determine tax rates.
		long customerAddressId = addressTable.getAdIdForCustomer(getCurrentCustID());
		int[] codes = addressTable.getDivisionAndCountryCodesForAddress(customerAddressId);

		int divCode = codes[0];
		int ctryCode = codes[1];

		// Get applicable tax rates from stub tables.
		double countryRate = custTaxrateTable.getCountryTaxRow(getCurrentCustID(), ctryCode).tx_rate;
		double divisionRate = custTaxrateTable.getDivisionTaxRow(getCurrentCustID(), divCode).tx_rate;

		double totalRate = ((double) ((int) (10000.0 * (countryRate + divisionRate) + 0.5)) / 10000.0);
		completedTradeInfo.tax = proceeds.multiply(totalRate);
	}

	/**
	 * Calculates the trade commission.
	 * <p>
	 * This method finds the correct commission rate by matching the customer tier,
	 * trade type, exchange, and trade quantity. It then calculates the commission
	 * as a percentage of the total trade value (price * quantity).
	 */
	private void generateTradeCommission()
	{
		int custTier = getCurrentCustTier();
		int tradeQty = getCurrentTradeQty();
		TradeType tradeType = getCurrentTradeType();
		String tradeTypeId = tradeTypeFile.get(tradeType.ordinal()).tt_id;
		ExchangeType exchange = securityFile.getExchangeIndex(getCurrentSecurityIndex());
		String exchangeId = exchangeFile.get(exchange.ordinal()).ex_id;

		for (CommissionRateDataFileRecord crRecord : commissionRateFile)
		{
			boolean tierMatch = custTier == crRecord.cr_c_tier;
			boolean typeMatch = tradeTypeId.equals(crRecord.cr_tt_id);
			boolean exchangeMatch = exchangeId.equals(crRecord.cr_ex_id);
			boolean qtyMatch = tradeQty >= crRecord.cr_from_qty && tradeQty <= crRecord.cr_to_qty;

			if (tierMatch && typeMatch && exchangeMatch && qtyMatch)
			{
				Money tradeValue = getCurrentTradePrice().multiply(tradeQty);

				completedTradeInfo.commission = tradeValue.multiply(crRecord.cr_rate).divide(100);

				return; // Found the matching rule, exit.
			}
		}
		// This should not be reached if configuration is correct.
		throw new IllegalStateException("Could not find a matching commission rate for the trade.");
	}

	/**
	 * Calculates the flat trade charge.
	 * <p>
	 * This method iterates through the charge rules and finds the one that matches
	 * the current trade's customer tier and type. It then assigns the corresponding
	 * charge amount to the {@code completedTradeInfo}.
	 */
	private void generateTradeCharge()
	{
		for (ChargeDataFileRecord chargeRow : chargeFile)
		{
			// Search for the customer tier
			if (getCurrentCustTier() == chargeRow.ch_c_tier)
			{
				TradeTypeDataFileRecord tradeTypeRow = tradeTypeFile.get(getCurrentTradeType().ordinal());

				// Search for the trade type
				if (tradeTypeRow.tt_id.equals(chargeRow.ch_tt_id))
				{
					// Found the correct charge
					completedTradeInfo.charge = new Money(chargeRow.ch_chrg);
					return;
				}
			}
		}

		// This should not be reached if configuration is correct.
		throw new IllegalStateException("Could not find a matching charge rule for the trade.");
	}

	/**
	 * Generates all final, complete row information for the current trade.
	 * <p>
	 * This method is called after a trade has been finalized (i.e., pulled from the
	 * priority queue). It orchestrates the generation of all related table rows by
	 * calling a sequence of helper methods. It populates the {@code tradeOutputRow}
	 * bundle with the complete data for one trade event.
	 */
	private void generateCompleteTrade()
	{
		// First, generate derived trade info like charge, commission, and tax.
		// This is a prerequisite for the other row generation methods.
		generateCompletedTradeInfo();

		// Generate the rows for each table in the correct order.
		generateTradeRow();
		generateTradeHistoryRow();
		generateCashTransactionRow();
		generateSettlementRow();

		// Update the year-to-date aggregates for the associated broker.
		brokerTable
				.updateTradeAndCommissionYTD(
						getCurrentBrokerId(),
						1, // Increment trade count by one
						tradeOutputRow.trade.T_COMM);

		// Increment the counter for successfully completed trades.
		currentCompletedTrades++;
	}

	/**
	 * Generates the complete SETTLEMENT row information.
	 * <p>
	 * This method always generates one settlement row per trade, detailing the
	 * final cash amount, due date (T+2), and whether the settlement was for a cash
	 * or margin account.
	 */
	private void generateSettlementRow()
	{
		settlementRowCount = 1;
		SettlementRow settlement = tradeOutputRow.settlement;

		settlement.SE_T_ID = getCurrentTradeID();
		settlement.SE_CASH_TYPE = getCurrentTradeIsCash() ? "Cash Account" : "Margin";
		settlement.SE_AMT = getCurrentSettlementAmount().dollarAmount();

		// Calculate the due date: Trade Completion Date + 2 days.
		DateTime dueDate = getCurrentTradeCompletionTime();
		dueDate.add(2, 0, false);
		dueDate.set(0, 0, 0, 0); // Zero out the time portion.
		settlement.SE_CASH_DUE_DATE = dueDate;
	}

	/**
	 * Generates the CASH_TRANSACTION row information.
	 * <p>
	 * A cash transaction row is only generated if the trade is settled with cash
	 * (i.e., not a margin trade).
	 */
	private void generateCashTransactionRow()
	{
		if (getCurrentTradeIsCash())
		{
			cashTransactionRowCount = 1;
			CashTransactionRow cashTxn = tradeOutputRow.cashTransaction;

			cashTxn.CT_DTS = getCurrentTradeCompletionTime();
			cashTxn.CT_T_ID = getCurrentTradeID();
			cashTxn.CT_AMT = getCurrentSettlementAmount().dollarAmount();

			String securityName = securityTable.createName(getCurrentSecurityIndex());

			cashTxn.CT_NAME = String
					.format(
							"%s %d shares of %s",
							tradeTypeFile.get(getCurrentTradeType().ordinal()).tt_name,
							getCurrentTradeQty(),
							securityName);
		}
		else
		{
			cashTransactionRowCount = 0; // No row to insert for margin trades.
		}
	}

	/**
	 * Generates the TRADE_HISTORY row(s) for the current trade.
	 * <p>
	 * Market orders generate two history rows (Submitted, Completed), while limit
	 * and stop-loss orders generate three (Pending, Submitted, Completed).
	 */
	private void generateTradeHistoryRow()
	{
		TradeType type = getCurrentTradeType();
		boolean isLimitOrder = (type == TradeType.STOP_LOSS) || (type == TradeType.LIMIT_SELL) || (type == TradeType.LIMIT_BUY);

		if (isLimitOrder)
		{
			tradeHistoryRowCount = 3;
			// Pending state
			tradeOutputRow.tradeHistory[0].TH_T_ID = getCurrentTradeID();
			tradeOutputRow.tradeHistory[0].TH_ST_ID = statusTypeFile.get(StatusType.PENDING.ordinal()).st_id;
			tradeOutputRow.tradeHistory[0].TH_DTS = getCurrentTradePendingTime();
			// Submitted state
			tradeOutputRow.tradeHistory[1].TH_T_ID = getCurrentTradeID();
			tradeOutputRow.tradeHistory[1].TH_ST_ID = statusTypeFile.get(StatusType.SUBMITTED.ordinal()).st_id;
			tradeOutputRow.tradeHistory[1].TH_DTS = getCurrentTradeSubmissionTime();
			// Completed state
			tradeOutputRow.tradeHistory[2].TH_T_ID = getCurrentTradeID();
			tradeOutputRow.tradeHistory[2].TH_ST_ID = statusTypeFile.get(StatusType.COMPLETED.ordinal()).st_id;
			tradeOutputRow.tradeHistory[2].TH_DTS = getCurrentTradeCompletionTime();
		}
		else
		{ // Market Order
			tradeHistoryRowCount = 2;
			// Submitted state
			tradeOutputRow.tradeHistory[0].TH_T_ID = getCurrentTradeID();
			tradeOutputRow.tradeHistory[0].TH_ST_ID = statusTypeFile.get(StatusType.SUBMITTED.ordinal()).st_id;
			tradeOutputRow.tradeHistory[0].TH_DTS = getCurrentTradeSubmissionTime();
			// Completed state
			tradeOutputRow.tradeHistory[1].TH_T_ID = getCurrentTradeID();
			tradeOutputRow.tradeHistory[1].TH_ST_ID = statusTypeFile.get(StatusType.COMPLETED.ordinal()).st_id;
			tradeOutputRow.tradeHistory[1].TH_DTS = getCurrentTradeCompletionTime();
		}
	}

	/**
	 * Generates the complete TRADE row information.
	 * <p>
	 * This method populates the main {@code TradeRow} object with data from various
	 * getters and the completed trade info structure. It sets IDs, prices, fees,
	 * timestamps, and other core attributes of the trade.
	 */
	private void generateTradeRow()
	{
		TradeRow trade = new TradeRow();

		trade.T_ID = getCurrentTradeID();
		trade.T_CA_ID = getCurrentAccID();
		trade.T_TT_ID = tradeTypeFile.get(getCurrentTradeType().ordinal()).tt_id;
		trade.T_ST_ID = statusTypeFile.get(getCurrentTradeStatus().ordinal()).st_id;

		// A trade is cash by default, unless it's a buy on margin.
		trade.T_IS_CASH = true;
		boolean isBuy = getCurrentTradeType() == TradeType.MARKET_BUY || getCurrentTradeType() == TradeType.LIMIT_BUY;

		if (isBuy && (rnd.rndPercent(PERCENT_BUYS_ON_MARGIN)))
		{
			trade.T_IS_CASH = false;
		}

		trade.T_EXEC_NAME = String.format("%s %s", person.getFirstName(getCurrentCustID()), person.getLastName(getCurrentCustID()));
		trade.T_S_SYMB = securityFile.createSymbol(getCurrentSecurityIndex());
		trade.T_BID_PRICE = getCurrentBidPrice().dollarAmount();
		trade.T_TRADE_PRICE = getCurrentTradePrice().dollarAmount();
		trade.T_QTY = getCurrentTradeQty();
		trade.T_CHRG = completedTradeInfo.charge.dollarAmount();
		trade.T_COMM = completedTradeInfo.commission.dollarAmount();
		trade.T_LIFO = getCurrentTradeIsLifo();
		trade.T_DTS = getCurrentTradeCompletionTime();

		// Set the tax amount based on the account's tax status.
		switch (getCurrentTaxStatus())
		{
		case NON_TAXABLE:
			trade.T_TAX = 0.0;
			break;
		case TAXABLE_AND_WITHHOLD:
		case TAXABLE_AND_DONT_WITHHOLD:
			trade.T_TAX = getCurrentTradeTax().dollarAmount();
			break;
		default:
			throw new IllegalStateException("Invalid tax status encountered.");
		}

		tradeOutputRow.trade = trade;
	}

	/**
	 * Generates a new HOLDING_HISTORY row and adds it to the current trade's
	 * output.
	 * <p>
	 * This method records the details of a holding modification. It's called when a
	 * trade liquidates part or all of an existing holding. A single trade can
	 * generate multiple holding history rows if it affects multiple prior holdings.
	 *
	 * @param holdingTradeId
	 *            The trade ID of the original holding being modified.
	 * @param tradeId
	 *            The trade ID of the current trade that is causing the
	 *            modification.
	 * @param beforeQty
	 *            The quantity of the holding before this modification.
	 * @param afterQty
	 *            The quantity of the holding after this modification.
	 */
	private void generateHoldingHistoryRow(long holdingTradeId, long tradeId, int beforeQty, int afterQty)
	{
		// Ensure we don't exceed the maximum number of history rows that can be stored
		// for one trade.
		if (holdingHistoryRowCount < MAX_HOLDING_HISTORY_ROWS_PER_TRADE)
		{
			// Get the next available HoldingHistoryRow object from the output bundle.
			HoldingHistoryRow row = tradeOutputRow.holdingHistory[holdingHistoryRowCount];

			// Populate the row with the details of the change.
			row.HH_H_T_ID = holdingTradeId;
			row.HH_T_ID = tradeId;
			row.HH_BEFORE_QTY = beforeQty;
			row.HH_AFTER_QTY = afterQty;

			// Increment the counter for the number of history rows generated for this
			// trade.
			holdingHistoryRowCount++;
		}
	}

	/**
	 * Updates holding information based on the most recently completed trade.
	 * <p>
	 * This method modifies the in-memory {@code customerHoldings} list to reflect
	 * the results of the trade stored in {@code newTrade}. It liquidates existing
	 * positions (longs for a sell, shorts for a buy) based on the LIFO/FIFO flag,
	 * creates new holding records if necessary, and calculates the total buy and
	 * sell value of any closed positions for tax purposes. It also generates
	 * detailed {@code HoldingHistoryRow} records for each modification.
	 */
	private void updateHoldings()
	{
		// Initialize state for this update
		completedTradeInfo.buyValue = new Money();
		completedTradeInfo.sellValue = new Money();
		holdingHistoryRowCount = 0;

		List<HoldingInfo> holdingList = getHoldingListForCurrentTrade();
		int neededQty = newTrade.tradeQty;
		boolean isLifo = newTrade.isLifo;

		// Determine if the trade is a buy or a sell
		boolean isBuyTrade = newTrade.tradeType == TradeType.MARKET_BUY || newTrade.tradeType == TradeType.LIMIT_BUY;

		if (isBuyTrade)
		{
			// LOGIC FOR A BUY TRADE: Use the buy quantity to close out any existing short
			// positions.
			ListIterator<HoldingInfo> iterator = positionAtHoldingList(holdingList, isLifo);

			// Iterate while there's still buy quantity to apply and holdings to check
			// while (!pHoldingList->empty() && pHolding->iTradeQty < 0 && iNeededQty > 0)
			while (neededQty > 0 && (isLifo ? iterator.hasPrevious() : iterator.hasNext()))
			{
				HoldingInfo holding = isLifo ? iterator.previous() : iterator.next();

				if (holding.tradeQty >= 0)
				{
					continue;
				}

				int holdQty = holding.tradeQty;
				holding.tradeQty += neededQty;

				if (holding.tradeQty > 0)
				{
					// Need to zero the qty for correct history row later
					holding.tradeQty = 0; // holding fully closed

					completedTradeInfo.sellValue.addEquals(holding.tradePrice.multiply(-holdQty));
					completedTradeInfo.buyValue.addEquals(getCurrentTradePrice().multiply(-holdQty));
				}
				else
				{
					completedTradeInfo.sellValue.addEquals(holding.tradePrice.multiply(neededQty));
					completedTradeInfo.buyValue.addEquals(getCurrentTradePrice().multiply(neededQty));
				}

				generateHoldingHistoryRow(holding.tradeId, newTrade.tradeId, holdQty, holding.tradeQty);

				if (holding.tradeQty == 0)
				{
					// The holding was completely closed out, remove it from the list.
					iterator.remove();
				}

				iterator = positionAtHoldingList(holdingList, isLifo);

				neededQty += holdQty;
			}

			// If there's still buy quantity left, create a new long position.
			if (neededQty > 0)
			{
				HoldingInfo newHolding = new HoldingInfo(newTrade.tradeId, neededQty, newTrade.tradePrice, getCurrentTradeCompletionTime(), newTrade.symbolIndex);
				holdingList.add(newHolding); // Add to the end of the list
				generateHoldingHistoryRow(newTrade.tradeId, newTrade.tradeId, 0, neededQty);
			}
		}
		else
		{
			// Sell trade
			// neededQty *= (-1); // make trade qty negative for convenience
			// Liquidate positive (long) holdings
			ListIterator<HoldingInfo> iterator = positionAtHoldingList(holdingList, isLifo);

			// Iterate while there's still sell quantity to apply and holdings to check
			while (neededQty > 0 && (isLifo ? iterator.hasPrevious() : iterator.hasNext()))
			{
				HoldingInfo holding = isLifo ? iterator.previous() : iterator.next();

				if (holding.tradeQty <= 0)
				{
					continue;
				}

				int holdQty = holding.tradeQty;

				holding.tradeQty -= neededQty;

				if (holding.tradeQty < 0)
				{
					// Need to zero the qty for correct history row later
					holding.tradeQty = 0; // holding fully closed

					completedTradeInfo.sellValue.addEquals(getCurrentTradePrice().multiply(holdQty));
					completedTradeInfo.buyValue.addEquals(holding.tradePrice.multiply(holdQty));
				}
				else
				{
					completedTradeInfo.sellValue.addEquals(getCurrentTradePrice().multiply(neededQty));
					completedTradeInfo.buyValue.addEquals(holding.tradePrice.multiply(neededQty));
				}

				generateHoldingHistoryRow(holding.tradeId, newTrade.tradeId, holdQty, holding.tradeQty);

				if (holding.tradeQty == 0)
				{
					// There was enough new quantity to fully close the old holding
					iterator.remove();
				}

				neededQty -= holdQty;
			}

			// If there's still sell quantity left, create a new short position.
			if (neededQty > 0)
			{
				HoldingInfo newHolding = new HoldingInfo(newTrade.tradeId, -neededQty, newTrade.tradePrice, getCurrentTradeCompletionTime(), newTrade.symbolIndex);

				// Note: insert should be at the same end all the time
				// provided delete (PositionAtHoldingList()) is different
				// depending on IsLifo.
				// Vice versa also works - delete is at the
				// same end and insert depends on IsLifo. However, TradeResult
				// inserts at the end, so let loader insert in the same end.
				//
				holdingList.add(newHolding); // Add to the end of the list
				generateHoldingHistoryRow(newTrade.tradeId, newTrade.tradeId, 0, -neededQty);
			}
		}
	}

	/**
	 * Finds the next individual holding item to be processed.
	 * <p>
	 * This helper method advances the internal iterators
	 * ({@code currentAccountForHolding}, {@code currentSecurityForHolding}, and the
	 * {@code currentSecurityHolding} iterator object) to point to the next valid
	 * holding across all customer accounts. It skips any empty holding lists. This
	 * method prepares the state for the next call to .
	 * {@code generateNextHolding()}.
	 *
	 * @return {@code true} if a valid holding was found and the iterators are
	 *         positioned correctly; {@code false} if all holdings have been
	 *         processed.
	 */
	private boolean findNextHolding()
	{
		// Loop as long as the current iterator is null or has been fully consumed.
		while (currentSecurityHoldingIterator == null || !currentSecurityHoldingIterator.hasNext())
		{
			// The current list is exhausted, so try to move to the next security's list.
			currentSecurityForHolding++;

			if (currentSecurityForHolding == MAX_SECURITIES_PER_ACCOUNT)
			{
				// Reached the end of securities for this account, so move to the next account.
				currentAccountForHolding++;
				currentSecurityForHolding = 0; // Reset the security index.

				if (currentAccountForHolding == loadUnitAccountCount)
				{
					// We have processed all accounts in this load unit.
					return false;
				}
			}

			// Get the new holding list at the updated account/security position.
			List<HoldingInfo> nextList = customerHoldings[currentAccountForHolding][currentSecurityForHolding];
			// Get a new iterator for this list.
			currentSecurityHoldingIterator = nextList.iterator();
		}

		// If the loop terminates, it means we have a valid iterator with at least one
		// more element.
		return true;
	}

	/**
	 * Finds the next non-empty holding list to be summarized.
	 * <p>
	 * This helper method advances the internal account and security iterators
	 * ({@code
	 * currentAccountForHoldingSummary} and {@code
	 * currentSecurityForHoldingSummary}) until it finds a list in the {@code
	 * customerHoldings} array that is not empty. It is designed to be called after
	 * processing a summary, to set up the state for the next call to {@code
	 * generateNextHoldingSummaryRow()}.
	 *
	 * @return {@code true} if a non-empty holding list was found; {@code false} if
	 *         all accounts have been processed and no more summaries can be
	 *         generated.
	 */
	private boolean findNextHoldingList()
	{
		do
		{
			// Advance to the next security slot.
			currentSecurityForHoldingSummary++;

			if (currentSecurityForHoldingSummary == MAX_SECURITIES_PER_ACCOUNT)
			{
				// If we've exhausted securities for the current account, move to the next
				// account.
				currentAccountForHoldingSummary++;
				currentSecurityForHoldingSummary = 0; // Reset security index for the new account.

				if (currentAccountForHoldingSummary == loadUnitAccountCount)
				{
					// If we've exhausted all accounts for this load unit, we are done.
					return false;
				}
			}
			// The loop continues as long as the list at the current position is empty.
		}
		while (customerHoldings[currentAccountForHoldingSummary][currentSecurityForHoldingSummary].isEmpty());

		// If the loop terminates, it's because we found a non-empty list.
		return true;
	}

	/*
	 * Generates the next HOLDING_SUMMARY row. <p> This method iterates through the
	 * in-memory holdings, which are organized by account and security. For the
	 * current account/security pair, it calculates the sum of all holding
	 * quantities and populates the {@code holdingSummaryRow} field. It then
	 * advances its internal pointers to the next non-empty holding list in
	 * preparation for the next call.
	 *
	 * @return {@code true} if a summary row was generated and more may be
	 * available; {@code false} if all holding summaries have been generated.
	 */
	public boolean generateNextHoldingSummaryRow()
	{
		// If the account iterator is past the last account for this load unit, we're
		// done.
		if (currentAccountForHoldingSummary >= loadUnitAccountCount)
		{
			return false;
		}

		// Populate the HoldingSummaryRow object for the current account/security pair.
		// The current position is guaranteed to point to a non-empty list by the
		// findNextHoldingList() helper method.
		holdingSummaryRow.HS_CA_ID = currentAccountForHoldingSummary + startFromAccount;

		long securityFlatFileIndex = holdingTable
				.getSecurityFlatFileIndex(
						holdingSummaryRow.HS_CA_ID,
						currentSecurityForHoldingSummary + 1 // The index is 1-based for this call
				);
		holdingSummaryRow.HS_S_SYMB = securityFile.createSymbol(securityFlatFileIndex);

		// Get the specific list of holdings for the current account and security.
		List<HoldingInfo> holdingList = customerHoldings[currentAccountForHoldingSummary][currentSecurityForHoldingSummary];

		// Sum the quantities of all holdings in the list using the Java Stream API.
		int totalQuantity = holdingList
				.stream()
				.mapToInt(holding -> holding.tradeQty)
				.sum();
		holdingSummaryRow.HS_QTY = totalQuantity;

		// Advance the internal iterators to the next non-empty holding list
		// and return whether one was found.
		return findNextHoldingList();
	}

	private DateTime getCurrentTradeSubmissionTime()
	{
		return fromSeconds(newTrade.submissionTime);
	}

	private DateTime getCurrentTradePendingTime()
	{
		return fromSeconds(newTrade.pendingTime);
	}

	private DateTime getCurrentTradeCompletionTime()
	{
		return fromSeconds(newTrade.completionTime);
	}

	private DateTime fromSeconds(double seconds)
	{
		DateTime dt = new DateTime(startTime);

		// Separate the total seconds into full days and the remaining milliseconds
		// to handle large values safely, mirroring the original C++ logic.
		int days = (int) (seconds / SECONDS_PER_DAY);
		int msec = (int) ((seconds % SECONDS_PER_DAY) * 1000);

		// Add the calculated duration to the start time.
		dt.add(days, msec, true); // The 'true' flag would handle weekend adjustments.

		return dt;
	}

	private TradeType generateTradeType()
	{
		TradeType tradeType;
		// Generate Trade Type
		// NOTE: The order of these "if" tests is significant!!
		// Do not alter it unless you know what you are doing.
		// :-)
		//
		int loadTradeTypePct = rnd.rndIntRange(1, 100);

		if (loadTradeTypePct <= MARKET_BUY_LOAD_THRESHOLD) // 1% - 30%
		{
			tradeType = TradeType.MARKET_BUY;
		}
		else if (loadTradeTypePct <= MARKET_SELL_LOAD_THRESHOLD) // 31% - 60%
		{
			tradeType = TradeType.MARKET_SELL;
		}
		else if (loadTradeTypePct <= LIMIT_BUY_LOAD_THRESHOLD) // 61% - 80%
		{
			tradeType = TradeType.LIMIT_BUY;
		}
		else if (loadTradeTypePct <= LIMIT_SELL_LOAD_THRESHOLD) // 81% - 90%
		{
			tradeType = TradeType.LIMIT_SELL;
		}
		else if (loadTradeTypePct <= STOP_LOSS_LOAD_THRESHOLD) // 91% - 100%
		{
			tradeType = TradeType.STOP_LOSS;
		}
		else
		{
			throw new IllegalArgumentException(); // this should never happen
		}

		return tradeType;
	}

	private Money getCurrentTradeSellValue()
	{
		return completedTradeInfo.sellValue;
	}

	private Money getCurrentTradeBuyValue()
	{
		return completedTradeInfo.buyValue;
	}

	private TaxStatus getCurrentTaxStatus()
	{
		return completedTradeInfo.accountTaxStatus;
	}

	private long getCurrentBrokerId()
	{
		return completedTradeInfo.currentBrokerId;
	}

	private Money getCurrentTradeTax()
	{
		return completedTradeInfo.tax;
	}

	private Money getCurrentSettlementAmount()
	{
		return completedTradeInfo.settlementAmount;
	}
}
